                                 
                                    
day-1

								  what is java?
								  
								   java is object oriented programming language
								   
								   
	
  what is the goal of programming language?

   
            to develop the software/application 

 			
	we do have two types of applications 
	
	 1.desktop application 
	 
	   desktop applications results are not sharable across the globe.
	   
	   
	   calculator
	   acroabtic reader
	   antivirus.
	   ....
	   
	   
	 2.distributed application
	 
	   results are sharable across the globe make sure you have proper internet connection.
	   
	   
	   facebook
	   gmail
	   flipkart
	   amazon...
	   
	
java got released in which year:
  1995
who is author?
  james gosling 
he released this software from which organization?

 sunmicrosystem





 he releaesd this software into threee editions
 
 
  1.jse
  
     ->desktop applications
	 
  2.jee
  
      ->desktop applications + distrubuted applications
	  
	  
  3.jme
  
     ->java micro/mobile edition 
	 
	 android 
  
significance of learning core java/jse:

->to implement desktop applications/standalone applications

->to learn jee

->to learn popular tools mulesoft,salesforce,tableu,hadoop...



1995
27 years back 

  because of it's java unique features.
  
  -13 features
  
  -simple
  -pi
  -an
  -dynamic
  -interpreted
  -multithreaded
  -secured
  -portable
  -object oriented 
  
  ....
  

platform independent:
`````````````````````

 c is platform dependent
 
 
 <filename>.c -> compile -> .exe ->windows os
 
 unix operating system 
 
   can't 
   
 
  compiled 
  executed
  
  
platform independent:
 
  .java ->.class file ->windows os
  
  yes
  
  java slogan -> wora -> write once run anywhere
  
  
  java software 
  
   
  
why java is object oriented?

 since this pl follows oops principles ->omg(object management group)-candian organization 
 
 
 
 inheritance
 polymorphism
 abstraction 
 encapsulation 
 
 .net,pyhton,php,cpp...
 
 


java is open source

java is case sensitive programming language


java -> sunmicrosystem

in recent years copy rights of sunmicrosystem reserved by oracle corporation 

 
  scjp
  
  ocjp
  
  
  url: www.oracle.com (signup) 
  
   
   
  
prerequistites to write the java program:
`````````````````````````````````````````
1.download the java software(jdk) and then install
2.select the editor (notepad,some ide's)eclipse,netbeans,myeclipse, 
2.write the java program 
4.save this java progra (<filename>.java)
5.compile the java program (.class)->java compiler
6.execute the java program ->output ->java interpretor (jvm)


jdk,jre,jvm:
```````````

jdk 
  java development kit
  https://www.oracle.com/in/java/technologies/downloads/
  
  
i wanted to cross check whether it gets installed or not?

open comand prompt and pass below command

  
    cmd:/> java -version 
	

with this jdk?
 am i able to write the java program 
 yes
 am i able to execute the java program 
 yes
 
 it provides 2 environments
 
  1.development environments
  2.runtime environments
  
  
 jre: java runtime environment 
 
 using this jre, 
 are we able to develop the java programs?
 no
 are we able to execute the java applications
 yes
 
 
 jvm: 
  java virtual machine
  
   using this we are able to execute the java program 
   
   

jdk = developement environment + jre

day-2
``````

structure of the java program:

 
  every java program should start with by defining a class.
  
  class <classname>
  {
   
  }
  
  
q) why should we compile the java program?

  compilation done by java compiler.
  
  java compiler : it is system defined program.
  
  
 how can we compile the java program?

 we do have one command is there 

  open the command prompt
  cmd:/> javac <filename>.java
  cmd:/> javac Welcome.java

  
NOTE:
when you compile the java program , if it compiles successfully 
.class file gets generated with class name


 Welcome
 HelloWorld.class
 
 
 .java file contains source code. 
 
 .class file contains bytecode.
 
 bytecode will be generated by compiler and this is not human readable
 code.
 
 
 
   -platform independent.
   
   
 
 
 
 jvm
 
we have to execute this file.


to execute this we have to give this .class file as an input to jvm 

  jvm will convert this bytecode to binary code.
  
  
what is the commadn to execute this java program?

  open the command prompt
  
   cmd:/> java HelloWorld


How to compile:
 
  javac <filename>.java
  
How to execute : 
   java <classname>
   
   
 note:
 
  every java program execution starts from main method.
  
  jvm internally invokes this main method.
  
  
java is object oriented programming language?

  because it follows oops principles.
  
  to achieve these oops principles in java we are using two concepts
  
   1.class
   2.object
   
   
class:
`````

class is the collection of variables and methods into a single unit.
this single unit is known as class.



variable:
 it is the name which we are giving to the memory location .
 
 
    100->memory area->system will generate one name 
	 
	 PQR444234234KLADJF
	 
	 stid=100;
	
	
while we are storing the data, we have to specify the type of the data. 
then only syntacticlly it is correct.
	
	numeric 
	character 
	string 
	float 
	...
	
	
for each and every type of data java provides some predefined data types
those are known as primitive data types.

note:
in java, datatypes can be categorized into 4 types

integer

  -byte
  -short
  -int
  -long

character

  -char

float

  -float
  -double

boolean 

  -boolean 
  
  
every datatype is having their own memory size and as well as 
range.

formula to calculate the range of any datatype:

 byte -> 1 byte -> 8 bits
 
 
  -2^n-1 to (2^n-1) - 1
  
  -2^7 to 2^7 -1
  
  -128 to 127
  
  byte b =100;
  short s = 100;
     int i = 100;
  long l =100;
  
  
 to store single character we have to use this char dataype
 
 character data always must be enclosed with in the single quotes.
 
   char c = 'a';
   
   float f = 123.45f;
   
   
note:
by default float data is of double type.

so that is why to store any float type after value must we have to 
add one character i.e f.

boolean :

  to store logical values whether it is true of false.
  
   boolean b = true;
   boolean b1 = false;
   
  note: 
  true and false are not normal words, these are java reserved keywords
  undefined 

  

variable syntax:
 
   variable initialization .
   
   
   
 <dataypename> <variablename> = <value>;
 
 int x;//variable declaration 
 x=100;//assignining the value
 int x = 100;//varaible initialization
 
 
method:
```````
method is the place where we are writing the logic to perform some operations based on requirement.


syntax:

   [accessmodifier] <returntype> <methodname>([if any parameters])
   {
      //logic
   }

example:

    void display()
	{
	  System.out.println("welcome to methods");
	}
	
    int getSalary()
	{
	  return 1000;
	}
	
	int sum(int a, int b)
	{
	   return a+b;
	}
	
	
	 sum(100,200);
	
	
 
 note: return type and return value must be compatible otherwise 
 it gives you compile time error.
 
while we are defining the methods we should follow some naming convention.

  GETAGE()

  getAge()
  getStudentInfo()
  
  
  
class is a collection of variables and methods into a single unit. 
that single unit is known as class.

 ex:
    
  class Student
  {
    //variables
    int stid=100;
    Strig stname="rama";
	
	//method name
	public void display()
	{
	 System.out.println(stid);
	 System.out.println(stname);
	}
 }
 
day-3:
```````
class is a collection 
 -variables
 -&methods 
 
 class <classname>
 {
 
   //varaibles
   
   //methods
 
 }
  
  
 object:
 ```````
 object is an instance of a class.
 
 instance:
 
  allocating sufficient amount of memory space for the non static properties 
  which we are defining inside the class. 
  
  
  note:
  for a single class, how many object(s) we can create?
  
   answer: as many as we want based on the requirement.
   
   
  
 1000 students.

 1000 student object.

 
  syntax to create the object:
  
   <classname> <objectname> = new <classname>();
   
   Student obj = new Student();
   
   Student obj1 = new Student();
   
   
   Student -> name of the class
   
   obj -> name of the object
   
   =  -> assignment operator
   
   
   new -> dynamic memory allocation operator
   
   Student() -> constructor
   
   
 // -> single line comment

/*

 */ -> multiline comment.

 
   
 example:
``````````
class Student
{
 int stid=100;
 String stname="Rama";
 
 public void display()
 {
   System.out.println("student id is : " + stid);
   System.out.println("student name is : " + stname);
 }
 
 
 public static void main(String[] args)
 {
    
	Student obj = new Student();
	
     System.out.println("student id is: " + obj.stid);
	 System.out.println("student name is : " + obj.stname);
	 System.out.println("===================");
	 //call the display() method
	 
	 obj.display();
	 
	 
 }
 
 }
 
 
instance vs static:
````````````````````
inside the class we can define instance properties and as well 
as static properties based on the requirement.

int stid;
static int stid;

void display()
{
}

static void display()
{
}

note:
to make any property as static property we have to use one java 
reserved keyword i.e static.


  
  
  college
   
     1000 students
	 
	   stid
	   stname
	   mobile
	   collegename
	   
	   
if a property is common for all the object(s) we can define that proeprty 
as static.

for static properties memory will be created at the time of class loading.
which is done by classloader subsystem it is the part of jvm.


	   
 static proeprties we can access using in these three possible ways.

  1.using classname(if property in one class, calling from another class)
  2.direct access (if property and calling is done in the same class)
  3.using object (not recommended)
  
  
  not static properties always we can acess using object name.
  
  
 instance(nonstatic) vs static area:


   
 the area which belongs to instance method or non static method is known 
 as instance area.
 
 
    //instance method
    public void display()
	{//instance area
	
	}
	
	public  static void  display()
	{
	//static area
	}
  
  
    java execution starts from main()
	
	public static void main(String[] args)
	{
	  //static area
	
	}
  


note:
````
from static area, to access the non-static properties using object name
it is possible.

from instance area, to access the instance properties direct access is 
possible.


from any area either instance / static area to access static properties
we do have following 3 possible ways.

   1.direct access
   2.using classname
   3.using object name(it is not at all recommended)
   
   
Student.java:
``````````````
class Student
{
	//non static properties
 int stid=100;
 String stname="Rama";
 
 
 //static property
 static String collegeName ="CBIT";
 
 
 public void display()
 {
	 //non-static or instance area
   System.out.println("student id is : " + stid);
   System.out.println("student name is : " + stname);
     System.out.println("student collegename is : " + collegeName);
	 System.out.println("student collegename is : " + this.collegeName);
	 System.out.println("student collegeName is: " + Student.collegeName);
 }
 
 
 public static void main(String[] args)
 {
    //static area
	Student obj = new Student();
	
     System.out.println("student id is: " + obj.stid);
	 System.out.println("student name is : " + obj.stname);
	 
	 System.out.println("student collegename is : " + collegeName);
	 System.out.println("student collegename is : " + obj.collegeName);
	 System.out.println("student collegeName is: " + Student.collegeName);
	 
	 System.out.println("===================");
	 //call the display() method
	 
	 obj.display();
	 
	 
 }
 
 }
 
 
Demo.java:
```````````
class Demo
{
	
	 public static void sum(int x, int y)
	 {
		 System.out.println("sum is: " + (x+y));
	 }
	 
	 public void add(int x, int y)
	 {
		   System.out.println("addition is: " +(x+y));
	 }
	 
 public static void main(String[] args)
 {
      //static area
	  sum(10,20);
	  
	  //call the add() which is instance method
	  
	 Demo obj = new Demo();
	  obj.add(20,30);
	  
	  
 }
 
}


command line arguments:
```````````````````````
whatever the input which we are passing while we are executing the program 
from the command prompt those areguments are known as
command line arguments.


  javac Demo.java
  
  java Demo 100 200
  
  
java.lang package

wrapper class:

The wrapper class in Java provides the mechanism to convert primitive into object and object into primitive


short -> Short -> short parseShort(String)
byte -> Byte -> byte parseByte(String)
int ->Integer -> int parseInt(String)

8 datatypes 

  -> 


why main() is taking String  as an arugment?

  to deal with command line arguments.
  
  
Demo.java:
``````````
class Demo
{
	 
 public static void main(String[] args)
 {
      
	String s1=args[0];
	String s2 = args[1];
	
	//convert first string value into integer value
	
	int fno = Integer.parseInt(s1);
	int sno = Integer.parseInt(s2);
	
	int result = fno+sno;
	
	System.out.println("sum is: " + result);
	
	 
	 
	 
 }
 
}


Demo.java:
```````````
class Demo
{
	 
 public static void main(String[] args)
 {
 
	System.out.println("sum is: " + (Integer.parseInt(args[0])+Integer.parseInt(args[1])));
 
 }
 
}




day-4:
```````

byte     Byte
short    Short
int      Integer
long     Long
float    Float
doube    Double
char     Character
boolean  Boolean


  to convert primitive type to object type and viceversa.
  
  autoboxing: converting primitive type to object type.
  autounboxing: converting object type to primitive type.
  
ide -> eclipse 

 ide ->integrated development environment

autointelligence
note: the code which we are writing inside ide is autocompiled.

 
eclipse is open source 
 -apache software foundation 
 url: https://www.eclipse.org/downloads/packages/release/helios/sr1/eclipse-ide-java-developers
 
 
 
  



example:
````````

public class Test {
	
	
	public static void main(String[] args) {
		//primitive type
		int x = 100;

		//auto boxing - primitive type to object type
        Integer y = Integer.valueOf(x);
        
        //auto unboxing - objet type to primitive type
        int z = y.intValue();
        
        System.out.println(z);
       
		
	}

}




autoboxing and unboxing:
`````````````````````````
Autoboxing is the automatic conversion that the Java compiler makes between the primitive types and their corresponding object wrapper classes. For example, converting an int to an Integer, a double to a Double, and so on. If the conversion goes the other way, this is called unboxing.


from jdk 1.5 version onwards these conversions are happening automatically 
by the java compiler.




String to Object and Object to String Conversion:

example:
`````````

public class Test {
	
	
	public static void main(String[] args) {
		//primitive type
		int x = 100;

		//auto boxing - primitive type to object type
        Integer y = Integer.valueOf(x);
        
        String z = y.toString();
        
        //int number = Integer.parseInt(z);
        Integer p = Integer.valueOf(z);
        
        System.out.println(z);
       
		
	}

}


type casting:
`````````````
we can perform this type casting at two levels.

 1. at primitive level 
 2. at referecne/object level 


type casting: 
conversion of one type data into another type data.

1. implicit type casting/widening type casting

       converting lower type to higher type 
	   
	   
	   it takes place 
	   both data types must be compatile with each other 
	   
	   the target type must be larger than the source type.
	   
	   
	   byte->short->char->int->long->float->double 
	   

example:
`````````

public class Test {
	
	
	public static void main(String[] args) {
		char c = 'a';
		int x =c;
		long y = x;
		float z = y;
		
		System.out.println("before conversion, char value: " + c);
		System.out.println("after conversion , int value: " + x);
		System.out.println("after conversion , long value: " + y);
		System.out.println("after conversion , float value: " + z);
		
	}

}


	    
2. explicit type casting/narrowing type casting

       converting higher type data to lower type data
	   
	   double -> flaot -> long -> int ->char ->short -> byte
	   
	   
example:
`````````

public class Test {
	
	
	public static void main(String[] args) {
		double d = 456.666;
		
		//converting double data type into long data type
		
		long l = (long)d;
		
		//converting long data type into int dataype
		
		int i =(int)l;
		
		System.out.println("Before conversion: " + d);
		System.out.println("After conversion into long type: " + l);
		System.out.println("After conversion into int type: " + i);
		
	}

}


	   


operator:

 operator in java is a symbol that is used to perform operations.
 
   unary operator
   Arithmetic Operator
   shift operator
   relational operator
   bitwise operator
   logical operator
   ternary operator
   assignment operator
   
   
unary operators require only one operand.

   -incrementing/decrementing a value by one
  
   pre increment post increment 
   
   ++a   a++
   
   --a   a--
   

example:
`````````

public class Test {
	
	
	public static void main(String[] args) {
		int a=10;
		System.out.println(a++);//10
		System.out.println(++a);//12
		System.out.println(a--);//12
		System.out.println(--a);//10
	
	}

}


example:
````````

public class Test {
	
	
	public static void main(String[] args) {
		int a=10;
		int b = 10;
		System.out.println(a++ + ++a);//10+12->22
		
		System.out.println(b++ + b++);//10+11->21
	
	}

}

day-5:
``````` 
relational operators
arithmetic operators(+,-,*,%,/)- to peroform arithmetic operators 
bitwise operators
shortcircuit operators
ternary operator
assignment operator




example:
`````````
public class Test {
public static void main(String[] args) {
	
		System.out.println(10+20);//30
		System.out.println(10*20);//200
		System.out.println(20-10);//10
		System.out.println(20/10);//2
		System.out.println(20%10);//0
	
		
		
	}

}


relational operators:
``````````````````````

to compare the values whether it is big or small 
 
 <
 <=
 >
 >=
 !=
 
example:
`````````
public class Test {
public static void main(String[] args) {
	
		System.out.println(10>20);//false
		System.out.println(10<20);//true
		System.out.println(20!=10);//true
		System.out.println(10==10);//true
		
		System.out.println((int)'a');
		System.out.println('a'>10);//true
	
	
		
		
	}

}



bitwise operators:
``````````````````

&-bitwise and

  T T -T
  T F -F
  F T -F
  F F -F
  
  
|-bitwise or
~-bitwise compliement
^-bitwise xor
 in case of bitwise xor 
 
  if both arguments are true -> false
  if both arguments are false -> false
  if any one argument is true -> true
  
example:
````````
public class Test {
public static void main(String[] args) {
	
		System.out.println(true&true);
		System.out.println(true&false);//false
		System.out.println(false&false);
		System.out.println(false&true);
	
		System.out.println(Integer.toBinaryString(4));
		System.out.println(Integer.toBinaryString(5));
	    System.out.println(4&5);//4
	    
	    System.out.println(false|false);
	    System.out.println(4|5);//5
	    
	    System.out.println(false^true);
		
	    System.out.println(4^5);
	    
	    System.out.println(~4);
	    
	    System.out.println(Integer.toBinaryString(-5));
	
	   
	    
	}

}

 



&&
||

in case of shortcirucit operators it won't check second argument if first argument is okay accordingly we will get the output. 

because of this performance and time of execution gets improved.

ternary operator:
`````````````````
String result = 10<20?"10 is lessthan 20":"10 is greater than 20"


example:
`````````
public class Test {
public static void main(String[] args) {
	
		int num1=20;
		int num2=10;
		
		int result;
		
		result = (num1>num2)?(num1+num2):(num1-num2);
		System.out.println(result);
	}

}


note: we are using very frequently for an alternative of if-else blocks.



control statements in java:
```````````````````````````
selection statements
  if else
  switch case
  
loop statements
  for 
  while
  do while
  for each 
  
transfer statements

  break
  continue
  assert
  
  
example:
````````
public class Test {
public static void main(String[] args) {
	
		int num1=10;
		int num2=10;
		
	    if(num1>num2)
	    {
	    	System.out.println(num1+num2);
	    }
	    else if(num1<num2)
	    {
	    	System.out.println(num1-num2);
	    }
	    else
	    {
	    	System.out.println("both the numbers are equal");
	    }
	}

}


switch case:
`````````````
switch(value or expression)
{


    case casevalue:
	   body
	   break;
	   
	case casevalue:
	   body
	   break;
	   
	default :
	body;

} 


example:
`````````
public class Test {
public static void main(String[] args) {
	
	
	
	int number=20;
	//switch expression 
	switch(number) {
	
	//case statements
	
	case 10: System.out.println("10"); 
	
	case 20: System.out.println("20");
	
	case 30: System.out.println("30");
	
	//default case statement
	
	default: System.out.println("not in 10, 20 or 30");
	
	}
}//closing main()



}//closing class


looping statements:
````````````````````
while loop

example:
```````
public class Test {
	public static void main(String[] args) {
	    int i=10;
		
		while(i<=1)
		{
			System.out.println(i);
			i--;
		}
		
		System.out.println("nothig is executed");
	
	}// closing main()

}// closing class

note:

in case of while loop, when condition is true then only inside the while 
loop statements will execute otherwise it will not execute.

when should we go for while loop?

when we are not aware about how many no.of time we would like to iterate
then we will go for while loop.


do while loop:
`````````````
in case of do while loop irresepective of condition is true or false
atlease one time the loop statement will be executed.

example:

public class Test {
	public static void main(String[] args) {
	    int i=11;
		do {
			System.out.println(i);
			i++;
		}
	    
	    while (i<=10);
		
	}// closing main()

}// closing class


for loop:
```````````

 for(initialization;conditionchecking;increment/decrement)
 {  
   //body
 }
 
example:
````````
public class Test {
	public static void main(String[] args) {
	  
		
		for(int i=1;i<=10;i++)
		{
			System.out.println(i);
		}
		System.out.println("nothing is executed");
	}// closing main()

}// closing class

example:
``````````
public class Test {
	public static void main(String[] args) {
	  
		
		for(int i=1;i<=10;i++)
		{
			
			if(i%2==0)
			{
				System.out.println(i);
			}
			
		}
		//System.out.println("nothing is executed");
	}// closing main()

}// closing class




continue:
`````````
public class Test {
	public static void main(String[] args) {
	  
		
		for(int i=1;i<=10;i++)
		{
			
			if(i%2==0)
			{
				continue;
			}
			System.out.println(i);
		}
		//System.out.println("nothing is executed");
	}// closing main()

}// closing class


day-6:
``````

 operators  & flow control statement
 
 constructor:
 ````````````
 object:
 
   instance of a class is known as object
   
   instance: to allocate/create the enough memory space for instance   properties of the class
 
 
  syntax:

    <classname> <objectname> = new <classname>();
	
	Student obj = new Student();
	
	
	Student() -> method 
	
   
 constructor is a special member method.
 

rule: constructor name and class name always must be same
      constructor should not return anything even void also.
	  
purpose:
      to initalize the object
	  
	  
    	  initialization -> assigning the values 
		  
		  
		majorly we do have two types of constructors


1.default constructor/no-args constructor
  -it is a constructor which doesn't takes any parameters
  
  -system defined default constructor
  
     -it will be generated by java compiler when we don't define any 
	  constructors inside the class.
	 
     -purpose: it will initialize the default values based on the 
               datatype.

  integer category datatypes -> default value -0
  float -0.0
  char -> single space
  String -> null
  boolean -> false

  
	  
  -user defined default constructor
  
  
    purpose: this will be intilizing our own values.
	
	
  
  
  note:
  `````
  java compiler first invokes default values into the object 
  and later our own values will be replaced.
  
  
example:
`````````

public class Student {
	// non-static properties
	int stid;
	String stname;

	// user defined default constructor

	/*
	 * public Student() { stid = 100; stname = "rama"; }
	 */

	// java compiler generates one system defined dc

	/*
	 * public Student() { stid=0; stname=null; }
	 */
	
	public void display() {
		System.out.println("student id: " + stid);
		System.out.println("student name: " + stname);
	}

	public static void main(String[] args) {

		// static area

		Student obj = new Student();
		// calling display() method using object name
		obj.display();
	}

}

  
  
  
2.parameterized constructor
		

   it is a constructor which takes parameters based on the requirement.
   
   
 note:
 when we are defining any parameterized constructor java compiler will 
 not generate any system defined default constructor.
 
 
note:
whenever we create the object automatically corresponding constructor(s) will get invoked.

example:
``````````

public class Student {
	// non-static properties
	int stid;
	String stname;

	//define double parameterized constructor
	public Student(int x, String y)
	{
		stid=x;
		stname=y;
	}
	
	public void display() {
		System.out.println("student id: " + stid);
		System.out.println("student name: " + stname);
	}

	public static void main(String[] args) {

		// static area

		Student obj = new Student(100,"rama");
		// calling display() method using object name
		obj.display();
		
		Student obj1 = new Student(101,"benny");
		obj1.display();
	}

}


advantages of defining constructor:
`````````````````````````````````````

  ->in case of constructor(s) we no  need to invoke explicitly the moment 
    we create the object(s) corresponding constructor(s) will get invoked.
	
  ->it is used to initalize the object.
  
  
difference between default constructor and parameterized constructor:

 in case of user defined default constructor, first compiler places the default values 
 into object and later our values will be replaced into the object.
 
 
 in case of parameterized constructor, directly our own values will be
 placed into an object.
 
 

for example in my class i have 1000 constructors are there ?

   

this keyword in java:
``````````````````````
whenever we declare class level variables and constructor level parameters
both are same to differentiate we have to use this keyword before class level  variables.




example:
``````````



public class Student {
	// non-static properties
	int stid;
	String stname;

	//user defined default constructor
	public Student()
	{
		stid=102;
		stname="bhaskar";
	}
	// double parameterized constructor
	public Student(int stid, String stname)
	{
		this.stid=stid;
		this.stname=stname;
		
	}
	
	public void display() {
		System.out.println("student id: " + stid);
		System.out.println("student name: " + stname);
	}

	public static void main(String[] args) {

		// static area

		Student obj = new Student(100,"rama");
		// calling display() method using object name
		obj.display();
		
		Student obj2 = new Student();
		obj2.display();
		
		
	}

}






this():
```````


this() -> it is used to call current class default constructor

this(...) -> it is used to call current class parameteized constructor


example:
```````
//example on constructor chaining 
public class Student {
	// non-static properties
	int stid;
	String stname;

	//user defined default constructor
	public Student()
	{
		//call the current class parameterize constructor using this()
		this(101,"Rama");
		
		this.display();
		
		
		stid=102;
		stname="bhaskar";
	}
	// double parameterized constructor
	public Student(int stid, String stname)
	{
		this.stid=stid;
		this.stname=stname;
		
	}
	
	public void display() {
		System.out.println("student id: " + this.stid);
		System.out.println("student name: " + this.stname);
	}

	public static void main(String[] args) {

		// static area

		Student obj = new Student();
		obj.display();
		
	}

}


note:
`````
while we are calling/invoking the current class constructor(s) this invocation  we have to stop in some constructor otherwise we will get 
compiletime error saying that recursive constructor invocation is not possible.

note:
``````
constructor calling always must be the first executable statement otherwise
we will get compile time error.


day-7:
``````

package:
````````
package is a collection of classes,interfaces and sub pacakges

  class - variables & methods
  interface -> methods & constants
  
  Integer - java.lang package
  
     all the predefined classes/interfaces are available in different
	 packages.
	 
jse,jee & jme
 
 jse has some predefined /builtin packages
note:
all the core java packages usually starts with java.


java.applet
java.awt
java.awt.color
java.awt.datatransfer
java.awt.dnd
java.awt.event
java.awt.font
java.awt.geom
java.awt.im
java.awt.im.spi
java.awt.image
java.awt.image.renderable
java.awt.print
java.beans
java.beans.beancontext
java.io


java.lang- default imported package

java.lang.annotation
java.lang.instrument
java.lang.invoke
java.lang.management
java.lang.ref
java.lang.reflect
java.math
java.net
java.nio
java.nio.channels
java.nio.channels.spi
java.nio.charset
java.nio.charset.spi
java.nio.file
java.nio.file.attribute
java.nio.file.spi
java.rmi
java.rmi.activation
java.rmi.dgc
java.rmi.registry
java.rmi.server
java.security
java.security.acl
java.security.cert
java.security.interfaces
java.security.spec
java.sql -
java.text
java.text.spi
java.util
java.util.concurrent
java.util.concurrent.atomic
java.util.concurrent.locks
java.util.jar
java.util.logging
java.util.prefs
java.util.regex
java.util.spi
java.util.zip

 
 purpose:
 ````````
 reusability
 avoid naming conflicts
 
 
how to define the package:
`````````````````````````

  package <packagename>;
  class 
  interface
  
  
 note: package statement always must be the first executable statement in java.

 
 naming convention for package:
 
  <reverseof your company domain>.<projectname>.<modulename>;
  
   com.infy.banking.withdrawl;
   
   
 how can we import the classes/interfaces from packages:

   
 import <pacakagename>.<classname>/<interfacename>

 import <packagename>.*;
 

when import is required?

  import is required when we are trying to access the properties of 
  differnt package from different package.
  
  
Test1.java:
````````````
package p1;
public class Test1 {
	
	public void sum(int x, int y)
	{
		System.out.println("sum is: " +(x+y));
	}
	

}

  
Test2.java:
````````````
package p1;

public class Test2 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(2, 3);
	}

}


Test2:
```````

package p2;
import p1.Test1;

public class Test2 {

	 public static void main(String[] args) {
		
		 Test1 obj = new Test1();
		 obj.sum(3, 4);
	 
	}
}



note:
````
by importing the main package, we are able to access only main package 
related properties 

by importing the main package, we won't get a chance to access sub package 
properties if we want to use sub package(s) properties we have to import 
sub package explicitly .

Test1.java:
```````````
package p1;
public class Test1 {
	
	public void sum(int x, int y)
	{
		System.out.println("sum is: " +(x+y));
	}
	

}

Test2.java:
````````````
package p1.p2;

public class Test2 {
	
	public void mul(int x, int y)
	{
		System.out.println("multiplication : " + (x*y));
	}

}

Test3.java:
package p3;

import p1.*;
import p1.p2.Test2;

public class Test3 {
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(3, 4);
		
		Test2 obj1 = new Test2();
		obj1.mul(3, 4);
		
		
	}

}

example on avoiding naming conflicts:
````````````````````````````````````
Test1.java:
``````````
package p1;

public class Test1 {
	
	public void sum(int x, int y)
	{
	System.out.println("sum: " + (x+y));
	}

}

Test1.java:
```````````
package p2;

public class Test1 {
	
	public void mul(int x, int y)
	{
	System.out.println("multiplication: " + (x*y));
	}

}

Test3.java:
`````````````
package p3;
import p1.Test1;


public class Test3 {
	public static void main(String[] args) {
		
		
		Test1 obj = new Test1();
		obj.sum(3, 4);
		
		p2.Test1 obj1 = new p2.Test1();
		obj1.mul(3,4);
		
	}

}




access modifiers:
``````````````````


these access modifiers are used to control the visiblity of the data
over the packages.


  private
  
  default(is not a keyword)
  
  protected
  
  public
  
 

private:
`````````
  
   private properties only we are able to access with in the class 
   we are not allowed to access outside the class even if it belongs 
   to same pacakge. 
   

Test1.java:
```````````
package p1;
public class Test1 {
	
	private void sum(int x, int y)
	{
		System.out.println("sum is: " +(x+y));
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(3, 4);
	}

}

Test2.java:
```````````
package p1;

public class Test2 {

	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(3,4);
	}
}

note:
when we are trying to access private properties from outside the class 
we will get compile time error saying that property is not visible.



   
  
  

















default:

  with in the class we can access
  
  outside the class from same package we can access
  
  from different package(s) classe we can't access 
  we will get compile time error -> saying that -> property not visible.
  
  
  
Test1.java:
`````````````
package p1;
public class Test1 {
	//default property
    void sum(int x, int y)
	{
		System.out.println("sum is: " +(x+y));
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(3, 4);
	}

}

Test2.java:
`````````````
package p1;

public class Test2 {

	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(3,4);
	}
}


Test3.java:
``````````
package p2;
import p1.Test1;
public class Test3 {

	public static void main(String[] args) {
		
		Test1 obj= new Test1();
		obj.sum(3,4);
		
	}
}


protected:
``````````
   with in the class
   same package another class we can access
   differnt package child classes we can  access? 
   from different pacakge independent classes we can't access.
   
   
 Test1.java:
 ````````````
 package p1;
public class Test1 {
	//protected property
    protected void sum(int x, int y)
	{
		System.out.println("sum is: " +(x+y));
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(3, 4);
	}

}

Test2.java:
````````````
package p1;

public class Test2 {

	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(3,4);
	}
}


Test3.java:
````````````
package p2;
import p1.Test1;

//different package child class
public class Test3 extends Test1 {

	public static void main(String[] args) {
		
		Test3 obj= new Test3();
		obj.sum(3,4);
		
	}
}


public :
```````
if you define any property as public we don't have any restriction 
from anywhere we can access. 

   public .
    
	  with in the class
	  same pacakge other classes
	  diffeente package classes 
	  
	  
	  
Test1.java:
`````````````
package p1;
public class Test1 {
	//public property
    public void sum(int x, int y)
	{
		System.out.println("sum is: " +(x+y));
	}
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(3, 4);
	}

}


Test2.java:
````````````
package p1;

public class Test2 {

	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		obj.sum(3,4);
	}
}

Test3.java:
````````````
package p2;
import p1.Test1;

//different package independent class
public class Test3 {

	public static void main(String[] args) {
		
		Test1 obj= new Test1();
		obj.sum(3,4);
		
	}ss
}





   



day-8:
```````

oops principles:

java is object oriented programming language

  because it is following oops principles 
  
   
    1.inheritance
	2.polymorphism
	3.abstraction 
	4.encapsulation 
	
	
inheritance:
````````````
 inheritance is the process of acquiring the properties from parent class 
 to child class.
 
 inhreitance is also known as is-a relation.
 
 to achieve the concept of inheritance we require minimum two classes
 with parent-child relation.
 
 
 ->reusablity
 ->code redundancy will be decreased
 ->performance of the application will be improved.
 
 
polymorphism:
`````````````
defining one action into many forms.


  class  person --> mentor object
  
  -->class son object
  
  -> class customer 
  
  compiletime polymorphism
  runtime polymorphism
  
->it allows programmers to reuse, evaluate and execute the program
->reducess coupling betwee different functioanlites.

 ->method overloading->readability of the code
 ->method overriding
 
   float rateOfInterest()
   {
   return 4.5f;
   }
 
 
abstraction:
`````````````
it is the process of retrieving required details.
by ignoring irrelevant details.


  ->interface 

 >security
 >modularity
 
  
encapsulation:
``````````````
it is the process of wrappingup of variables and methods into a single unit.


  class is best example for encapsulation
  
  
  datahiding
  
  
benefits of oops principles:

  ->enhancements
  ->resuablity
  ->security
  ->modularity
  ->easy maintainence
  ->debugging etc..
  
  
using two concepts
 class
 object
 

inheritance:
````````````

it is the process of taking the properties from parent class
to child class.


parent class:

it is a class which is giving the properties

child class:

it is also a class which is taking the properties


example:
````````

Parent.java:
````````````

package com.jse.inheritance;

public class Parent {
	
	public void sum(int x, int y)
	{
		System.out.println("sum: " + (x+y));
	}

}

Child.java:
```````````
package com.jse.inheritance;

public class Child extends Parent{

	public void sub(int x, int y)
	{
		System.out.println("substraction: " + (x-y));
	}
}

Test1.java:
```````````
package com.jse.inheritance;

public class Test1 {
	
	public static void main(String[] args) {
		
		//Parent obj = new Parent();
		Child obj = new Child();
		
		obj.sum(3, 4);
		obj.sub(4, 3);
		
	}

}

note:
`````
using extends keyword we are able to acheive the inheritance concept.

we should always use extends keyword in the context of child class only.


note:
`````
for every java class whether it is predefined or userdefined 
we have one super class i.e. 
java.lang.Object

exaple:
`````````

package com.jse.inheritance;

public class Test2 {
	
	public void m1()
	{
		System.out.println("Test2 - m1 method");
	}
	public static void main(String[] args) {
		
		Test2 obj = new Test2();
		obj.m1();
		
		Test2 obj1 = new Test2();
		System.out.println(obj.hashCode());
		System.out.println(obj.getClass());
		System.out.println(obj.toString());
		
	}

}

note:
`````
whenever we are displaying any java class object, it is internally invokes
toString() method of the class.


types of inheritances:
```````````````````````
  single inheritance
  multilevel inheritance
    multiple inheritance -not possible through the concept of classes.
  hierarchical inheritance
  hybrid inheritance
  
  
simple inheriance:
 
   it contains one parent class one child class
   
   
  
A
|
B

multilevel inheritance:

it contains one parent class, one child class and multiple intermediate 
parent classe(s).



A
|
B
|
C

  class A {}
  class B extends A{}
  class C extends B {}
  

intermediate parent class:
this is also a class in one context it is acting as child class and in 
another context it is acting as a child class. 


multiple inheritance:
``````````````````````

  A B C ...
  
    Z
	
	mutliple inheritance contains 
	multiple parent clases 
	and single child class .
	
	class A{ m1()}
	class B{ m1()}
	class C{ m1()}...
	
	class Z extends A,B,C...
	{
	  Z obj = new Z();
	  obj.m1();
	}
	
note:
`````
using extends keyword we are always extending one class at a time.

hierarchical inheriance:
````````````````````````
    A

B   C  D....


It contains single parent class and multiple child classes


class A{}

class B extends A{}
class C extends A{}
class D extends A{}



Hybrid inheritance:

  it is a combination of any two possbile inheritance type(S).
  
  A 
  |
  B
  |
C  D  E ...

Make sure in that combination multiple inheritance is not allowed.

note:
````
when we apply the inheritance concept, it is highly recommended to create
the object for child class.

when we create the object for child class, two memory copies won't be 
generated for both parent class and child class only one memory copy 
gets generated and that will be accessed by both parent class and as wella
as child class.


Parent.java:
`````````````
package com.jse.inheritance;

public class Parent  {
	
	public Parent()
	{
		System.out.println(this.hashCode());
	}

}

Child.java:
```````````

package com.jse.inheritance;

public class Child extends Parent{

	public Child()
	{
		System.out.println(this.hashCode());
	}
}

Test1.java:
```````````

package com.jse.inheritance;

public class Test1 {
	
	public static void main(String[] args) {
		
		Child obj = new Child();
		
		
	}

}



day-9:
`````

polymorphism:
`````````````
poly -many
morphism -forms


 we do have two types of polymorphisms are there
 1.compile time polymorphism
 2.runtime polymorphism
 

method overloading-
method overriding-




method overloading:
```````````````````

  method overloading is the process of defining the method name as same
  by changing signature.
  
  
    method name is same
    signature is different
	  -no.of arguments
	  -type of arguments
	  -order of arguments 
	  
	  
  public void m1(int x)
  {
    //logic
  }
  
  public void m1(float x)
  {
    //logic
  }
  


demo program:
``````````````
package com.jse.inheritance;

public class Test2 {
	
	
	public void m1(int x)
	{
		System.out.println("integer argument");
	}
	
	public void m1(String x)
	{
		System.out.println("String argument");
	}
	
	
	public static void main(String[] args) {
		
		Test2 obj = new Test2();
		obj.m1(100);
		obj.m1("rama");
		
		
		
	}

}

compile time polymorphism:
``````````````````````````
this is the polymorphism where method resolution or binding can be decided
at compiletime by the java compiler based on the reference variable not 
based on the object type.


method overloading is the best example for compile time polymorphism.

example:
````````
package com.jse.inheritance;

public class Test2 {
	
	
	public void m1(int x)
	{
		System.out.println("integer argument");
	}
	
	public void m1(float x)
	{
		System.out.println("float argument");
	}
	
	
	public static void main(String[] args) {
		//object declaration 
		Test2 obj;
		//object referencing
		obj= new Test2();
		
		obj.m1(100);//method resolution will be happend at compile time based on reference variable
		obj.m1(3.4f);
		
		
	}


}



example on method overloading with automatic/implict promotion:
````````````````````````````````````````````````````````````````
package com.jse.inheritance;

public class Test2 {
	
	// byte->short->char->int->long->float->double 
	/*
	 * public void m1(int x) { System.out.println("integer argument"); }
	 */
	
	public void m1(float x)
	{
		System.out.println("float argument");
	}
	
	
	public static void main(String[] args) {
		//object declaration 
		Test2 obj;
		//object referencing
		obj= new Test2();
		
		obj.m1(100);//method resolution will be happend at compile time based on reference variable
		obj.m1(3.4f);
		obj.m1('c');//integer argument
		obj.m1(20L);//float argument
		
		//compile time error:obj.m1(34.56);
	
	}

}


case:
``````
package com.jse.inheritance;

public class Test2 {
	
	public void m1(int x, float y)
	{
		System.out.println("int-float argument");
	}
	
	public void m1(float x, int y)
	{
		System.out.println("float-int argument");
	}
	
	
	public static void main(String[] args) {
		
		
		Test2 obj = new Test2();
		obj.m1(100,24.f);
		obj.m1(24.f,100);
		//obj.m1(10,10);->compile time error
		//obj.m1(10.5f,4.5f);->compile time error
		
	}

}


case:
`````
package com.jse.inheritance;

public class Test2 {
	
	public void m1(Object o)
	{
		System.out.println("object class");
	}
	
	public void m1(String s)
	{
		System.out.println("String class");
	}
	
	public static void main(String[] args) {
		
		
		Test2 obj = new Test2();
		
		obj.m1(new Object());
		obj.m1(new String("Rama"));
		obj.m1(null);
		
		
	}

}


note:
`````
if exact match is not there java compiler will give the prefernce to subclass version i.e.the method which is accepting String as an argument.

example:
`````````
package com.jse.inheritance;

public class Test2 {
	

	
	public void m1(String s)
	{
		System.out.println("String version");
	}
	public void m1(StringBuffer sb)
	{
		System.out.println("StringBuffer version");
	}
	
	public static void main(String[] args) {
		
		
		Test2 obj = new Test2();
		obj.m1("rama");
		
		obj.m1(new StringBuffer("rama"));
		
		//obj.m1(null);->compile time error
		
	}

}


note:
````
to perform method overloading one java class is enough.


method overriding:
````````````````````

   it is the process of defining method name as same 
   but logic is different from parent class to child class.
   
   note:
   to perform method overriding, minimum we require two classes 
   with parent child relation.
   
   
note:
`````
it is highly recommended to use @Override annotation on top of overriding 
method.

example:
`````````
package com.jse.inheritance;

public class Parent  {
	//overriden method
	public void operation(int x, int y)
	{
	  System.out.println("sum: " +(x+y));
	}
}

Child.java:
``````````
package com.jse.inheritance;

public class Child extends Parent {

	//overriding method
	@Override
	public void operation(int x, int y) {
		System.out.println("multiplicaton: " + (x*y));
	}
	
}

Test1.java:
````````````
package com.jse.inheritance;

public class Test1 {
	
	public static void main(String[] args) {
		
		
		Child obj = new Child();
		obj.operation(4, 5);
	}

}


note:
`````
private methods can't be overriden.

note:
`````
while we are overridng the method, it is always possible to increase the
visibility scope not possible to decrease the scope of the visibility.

   private < default < protectd < public.
   
   
note:
``````
final methods can't be participated in overriding.


non final to final is possible while we are overriding.

but final to not final is not possible.

method overriding with respect to exceptions. we do have some rules.

runtime polymorphism:

method resolution can be happend at runtime based on the object type 
not based on the refernce variable. 

Parent.java:
``````````````

package com.jse.inheritance;

public class Parent  {
	//overriden method
	public  void operation(int x, int y)
	{
	  System.out.println("sum: " +(x+y));
	}
}

//private<default<protected<public




Child.java:
````````````
package com.jse.inheritance;

public class Child extends Parent {

	//overriding method
	
	public  void operation(int x, int y){
		System.out.println("multiplicaton: " + (x*y));
	}
	
	public void m1()
	{
		System.out.println("child specific method");
	}
	
}


Test1.java:
```````````
package com.jse.inheritance;

public class Test1 {
	
	public static void main(String[] args) {
		
		
		Child obj = new Child();
		obj.operation(4, 5);
		obj.m1();
		
		Parent obj1 = new Parent();
		obj1.operation(3,4);
		
		//object type casting downcasting,upcasting
		Parent obj2;
		obj2= new Child();
		obj2.operation(3, 4);
		//compile time error: obj2.m1();
		
	}

}

assignment:
try to override the static method.

  
day-10:
````````

abstraction:
````````````
abstraction is one of the ooop principle.

highlighting the services which are offered by the company 
by hiding implementation details.



       insert atm card -> enter the pin -> withdraw the money
	   
	   
sending the whatsapp message-> 

  security
  enhancements
  modularity
  maintainence
  
  ->abstract class(partial abstraction)
  ->interface
  
  

abstract class:
```````````````
partial implementation class.

in java, we have two types of classes 

  ->concrete class / implementation class/fully defined class
  
  ->abstract class /parital implementation class //undefined classs
  
  
  
concrete class: is a class which contains only defined methods

defined method: it is a method which contains method heading + method body

abstract class: 
it is a class which contains both defined methods and as well as 
undefined methods also.

  abstract class Test1{
     //concrete method
     void m1(){System.out.println("m1");}
	 //abstract method or undefind method 
     abstract void m2();
  
  }
  
    
	


note:
`````
to make normal method as an abstract method we have to use abstract keyword
explicitly.

if a class contains atleast one abstract method the corresponding class 
also will become as abstract class.


q)are we able to create the object for abstract class or not?

 no, we are not allowed to create the object for an abstract class.
 
 
 
 
if a method is going to be common for all the implementation classes 
then it is highly recommended 

method name is common 
but logic is different from one implementation class to another implementation  class.

Test1.java:
```````````
package com.jse.abstraction;
//abstract class or undefined class
public abstract class Test1 {
	//defined method
	public void sum(int x, int y)
	{
		System.out.println("sum: " + (x+y));
	}
	//abstract method or undefined method
	public abstract void sub(int x, int y);
	
	public Test1()
	{
		System.out.println("constructor");
	}

}


Test2.java:
````````````
package com.jse.abstraction;

//child class cum implementation class cum execution logic class
public class Test2 extends Test1 {

	@Override
	public void sub(int x, int y) {
		System.out.println("substraction: " + (x - y));

	}
	
	public static void main(String[] args) {
		
		Test2 obj = new Test2();
		
		obj.sum(3, 4);
		obj.sub(4, 3);
		
	}

}


Test3.java:
````````````
package com.jse.abstraction;

public class Test3 extends Test1 {

	@Override
	public void sub(int x, int y) {
		System.out.println("multiplication: " + (x*y));

	}
	public static void main(String[] args) {
		
		
		Test1 obj;
		obj= new Test3();
		
		obj.sub(4, 3);;
	}

}





can we define constructor inside an abstract class?

   yes we can define
   
  constructor(s) always executed whenever we create the object.
  
  
because for every constructor super() statement is added by the java compiler internally 
which inturns calls parent class constructor(s).


note:
if we want to define the implementation class for any abstract class 
we have to provide the logic for all the abstract method if you are not 
providing the logic for atleast one abstract method then the implemention 
class also will become an abstract class.



day-11 session:
``````````````

  abstraction in java using two 
  
  1.abstract class
  2.interface
  

2.interface:
``````````````
interface is a collection of only abstract methods only unimplemented methods.

basically interface is used to provide or declare specifications. 

 >security,maintainence,enhancements,...
 
 
 syntax:
 
            interface <interfacename>
			{
			
			   //abstract methods
			}

how can we bring the properties from interface to class?

  using "implements" keyword 

  
  
  
extends -> class to class or interface to interface (homogenious)
implements -> interface to class to provide the logic




i1.java:
````````
package com.jse.abstraction;

public interface i1 {

	public void sum(int x, int y);
}


Test4.java:
````````````

package com.jse.abstraction;
//implementation class cum execution logic class
public  class Test4 implements i1  {

	@Override
	public void sum(int x, int y) {
		System.out.println("sum is: " +(x+y));
		
	}
	
	public static void main(String[] args) {
		
		i1 obj  = new Test4();
		obj.sum(2, 3);
		
	}

	

}


Test5.java:
````````````
package com.jse.abstraction;

public class Test5 implements i1 {

	@Override
	public void sum(int x, int y) {
		System.out.println("substraction: " +(x-y));
	}
	
	public static void main(String[] args) {
		
		
		i1 obj = new Test5();
		obj.sum(5,4);
	}

}


note:
if we take the properties from interface to class, we have to provide the 
logic for each and every abstract method otherwise the implementation class
also will become as abstract class.


note:
we can define the implementation class by implementing from more than one interface since java supports multiple inheritance through the concept of 
interface.


interface inheritance:

the process of taking the properties from interface to another interface
or parent interface to child interface.


i1.java:
````````
package com.jse.abstraction;

public interface i1 {

	public void sum(int x, int y);
	
	
}


i2.java:
````````
package com.jse.abstraction;

//sub interface or child interface or interface inheritance
public interface i2 extends i1 {
	
	public void mul(int x, int y);

}


Test4.java:
```````````
package com.jse.abstraction;
//implementation class cum execution logic class
public  class Test4 implements i2  {

	@Override
	public void sum(int x, int y) {
		System.out.println("sum is: " +(x+y));
		
	}
	
	@Override
	public void mul(int x, int y) {
		System.out.println("mutlitplication: "  +(x*y));
		
	}
	
	public static void main(String[] args) {
		
		/*Test4 obj = new Test4();
		obj.sum(3, 4);
		obj.mul(4, 5);*/
		
		i2 obj = new Test4();
		obj.sum(3, 4);
		obj.mul(3, 4);
		
	}

}

note:
`````
by default interface methods are public abstract and by default 
interface variables are public static final.



one use case:
```````````

Bank as an interface 
   
   interface Bank{
     double getRateOfInterest()
	}
	
method name is common 
but logic is different from one implementation class to another 
implementation class.

	
note:
like class, for interface also java compiler will generate .class file(s)

Bank.java:
``````````
package com.jse.abstraction;

public interface Bank {
	
	double getRateOfInterest();

}

Icici.java:
```````````
package com.jse.abstraction;

public class Icici implements Bank {

	@Override
	 public double getRateOfInterest() {
		return 6.1;
	}

}

CityBank.java:
`````````````
package com.jse.abstraction;

public class CityBank implements Bank {

	@Override
	public double getRateOfInterest() {
		// TODO Auto-generated method stub
		return 8.5;
	}

}

Test6.java:
```````````
package com.jse.abstraction;

public class Test6 {
	
	public static void main(String[] args) {
		
		Bank obj = new Icici();
		System.out.println("icici bank rate of interest is: " + obj.getRateOfInterest());
		Bank cb = new  CityBank();
		System.out.println("city bank rate of interest is : " + cb.getRateOfInterest());
	}

}

encapsulation:
``````````````
 advantage: data hiding 
 
encapsulation is the process of wrapping up of variables and methods 
into a single unit.


 to make any java class as an encapsulated class, we have to follow 
 below rules.
 
  1.each variable must be private(data hiding)
  2. for every variable we have to maintain both  public getter methods and as well as public setter methods.

  
note:
using encapsulaion, we do have more control on top of data. 

Student.java:
``````````````
package com.jse.abstraction;
//encapsulated class-data hiding
public class Student {
	//private variables
	private int stid;
	private String stname;
	//setter method
	public void setStid(int stid)
	{
		this.stid=stid;
	}
	//getter method
	public int getStid()
	{
		return stid;
	}
	
	public void setStname(String stname)
	{
		this.stname=stname;
	}
	
	public String getStname()
	{
		return stname;
	}

}

Test7.java:
```````````

package com.jse.abstraction;

public class Test7 {
	
	public static void main(String[] args) {
		
		
		Student obj = new Student();
		
		obj.setStid(100);
		obj.setStname("rama");
		
		System.out.println("student id: " + obj.getStid());
		
		System.out.println("student name:  " + obj.getStname());
		
	}

}


 	 
  


day-12 session:
````````````````
object type casting:
`````````````````````
type casting at primitive level 

  widening type casting/implicit  from lower datatype to higher datatype
  
   int x = 100; long y =100;
   
   long y = x;  int x =(int)y;
   

we may have parent class, and child class 

  parent object 
  child object
  
  downcasting ->from parent object type to child object type
  
     explicitly we have to perform this.
  
  upcasting ->from child object type to parent objec type
  
     it happend automatically



3 rules of object typecasting:
``````````````````````````````

 Object obj = new Object();
 
 String str = (String)obj;
  A      b      C      d
  
  
rule1:
```````
the type of d and C must have some relationship
either parent to child or child to parent or same otherwise we will 
get compile time error.

rule2:
```````
C must be either same or derived type of A, 
otherwise we will get compile time error.

rule3(at runtime)
````````````````````
the underlying original object type of 'd' must be either same or 
derived type of 'C'.

  




day-13 finished







day-14:
```````
exception handling:
``````````````````

  java is robust
  
exception:

  compile->compile time errors -> not following syntaxes
  run->jvm ->
  
    100 20
	 120
	 jvm will process only valid input
	 jvm will not process invalid data.
	 
	 
jvm will give you error -> exception 


runtime error -exception 


drawbacks of exception:

 ->control terminated abnormally
 ->it gives system error messages which are not understandable by 
   end user(s).
   
   
---
-
- int x= 100/0;
=-
997 lines 

100 lines of code 


  java.lang.ArithmeticException: /by zero
  
  5000
  7000
   insufficient fund's please check ur account
   
   
	
	
  



we can handle the exceptions using few keywords in java

 1.try
 2.catch
 
 3.finally
 
 4. throws
 5.throw 
 
 advantages of handling exceptions:
 
 1. achieving normal flow of execution 
 2. getting user friendly messages instead of system error messages
 
 


every exception is internally it is a class.


types of execptions:

 1.predefined exceptions-
 >pre defined classes 
 available in predefined pacakge(S)
 
  pre-defined exceptions are the predefined classes 
  which are available in pre defined packages.
  
  purpose: 
  to handle universal problems
  
  passing 0 as denominator
  passing alphabet to perform arithmetic operators
  ...
  
  IOException (java.io)
  SQLException (java.sql)
  ...
  
  
 
 
 2.user defined excepitons
 
 
   user defined exceptions are also user defined classes 
   purpose: to handle our own problems
   
   
     age -> -98
	 
	   InvalidAgeException 
	   
	   100kg -valid product
	   90kg -> InvalidProductException 
	   
	   

exception class hierarchy:
`````````````````````````

 predefined exceptions 

   -synchronous exceptions ->programtical logical errors
   
   note: 
   for all synchronous exceptions we are using java.lang.Exception as 
   the super class.
   
   1.unchecked exceptions->RuntimeException 
   
   2.checked exceptions
   
   
     java.lang.Exception 
	 
   
Object
 Throwable   
  Exceptioon   
   RuntimException
      ArithmeticExcpeption 
	  NumberFormatException 
	  ...
   
   -asynhronous exceptions->hardware failures
   
    Error 
     OutOfMemoryError
	 StackOverFlowError
	
 unchecked exceptions


 ->at runtime
CHECKED exceptions are checked by java compiler to esacpe from runtime error(s).


 day-15:
 ```````
try
catch
finally
throws
throw

try:
````
using try block what we can do?

purpose: it is used to keep the problematic statements which causes
problems at runtime.


try
{
//problematic statments
}

catch block:
````````````
catch block is used to catch the specific exception and provides user friendly message.

  catch(<exceptionclassname> <variablename>)
  {
   //user friendly message
  }
  


synchrnous exceptions 

  checked 
      checked execptions are checked by java compiler to esacape from 
	  runtime errors. 
	  
	  FileNotFoundException 
	  IOException 
	  ClassNotFoundException 
	  SQLException 
	  
	     -Exception 
  un-checked exceptions are checked by jvm only at runtime 
  
    ->RuntimException


while we are handling the exceptions we have to maintain the order
from specific to general otherwise we will get compiletime error saying 
that unreachable catch block .

example:
`````````
package com.jse.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;

public class Test1 {
	
	public static void main(String[] args) {
		try {
		Scanner s = new Scanner(System.in);
		
		System.out.println("enter first number");
		int x = s.nextInt();
		
		System.out.println("enter second number");
		int y = s.nextInt();
		
		int z = x/y;
		
		System.out.println("division: " + z);
		}
	
		
		/*
		 * catch(ArithmeticException ae) {
		 * System.out.println("don't enter zero as a denominator"); }
		 * catch(InputMismatchException ime) {
		 * System.out.println("please pass only numeric values"); }
		 */
		
		
		catch(RuntimeException re)
		{
			if(re instanceof ArithmeticException)
				System.out.println("don't enter zero as a denominator");
			if(re instanceof InputMismatchException)
				System.out.println("please pass only numerics");
		}
		 
		
		System.out.println("rest of the statements executed");
		System.out.println("rest of the statements executed");
		System.out.println("rest of the statements executed");
		
		
		
	}

}

instanceof operator:
instanceof operator is used to check the type of instance

example:
````````
package com.jse.exceptions;

import java.util.ArrayList;

public class Test2 extends Test1{
	
	public static void main(String[] args) {
		
		Test2 obj1 = new Test2();
		Test1 obj2 = new Test1();
	
		System.out.println(obj1 instanceof Test2);
		System.out.println(obj2 instanceof Test2);
	}

}




finally:
````````
finally block is used to keep closing related logic.


--
--
-- opening the file
--
-- int x = 100/20;
--
--finally{
--closing the logic
}

try with only finally without catch block is possible
try with finally along with catch also fine.
but make sure in between try and catch we should not add finally after try 
block always it is expecting catch block only if it is there.


day-16:
```````
throws and throw

throws:
``````
throws is  java reserved keyword
purpose: 
it is giving indication to calling function to keep the called function 
under try and catch block.

Test5.java:
```````````
package com.jse.exceptions;
//called program
public class Test5 {
	//called function
	public void division() throws ArithmeticException
	{
	  	//java.lang.ArithmeticException
	  int x = 100/0;
	}

}

Test6.java:
````````````
package com.jse.exceptions;
//calling program
public class Test6 {
	
	//calling function
	public static void main(String[] args) {
		
		Test5 obj = new Test5();
		
		try {
		obj.division();
		}
		catch(ArithmeticException ae)
		{
			System.out.println("something wrong in division method");
		}
		
		System.out.println("rest of statements also got executed");
	}

}



throw:
``````
throw is a java reserved keyword used to throw an exception explicitly.


syntax:

     throw new <exceptionclassname>();
	 
	 
 ArithmeticException can be thrown by jvm automatically when it met 
 some condition 
 
   creating an object only.
   
 
 
take one scenario
 
 ecommerce project
   
     product based on the weight
	 
	 if weight is >100 product is valid
	 else 
	 
	   InvalidProductException
	   
	   
	 
or it is used to define customized execptions or user defined exceptions.


package com.jse.exceptions;

public class Test7 {

	public void checkProduct(int weight) {
		if (weight > 100) {
			System.out.println("product is valid");
		} else {
			try {
				throw new InvalidProductException();
			} catch (InvalidProductException ipe) {
				System.out.println("product weight must be greater than 100kgs");
			}
		}
		System.out.println("rest of the statements executed");
	}

	public static void main(String[] args) {

		Test7 obj = new Test7();
		obj.checkProduct(20);
	}

}

InvalidProductException.java:
```````````````````````````````
package com.jse.exceptions;

public class InvalidProductException extends Exception  {

}


day-17:
```````

File handling in java:
````````````````````````
io streams

 -input output stream
 
 
stream: 
 flow of data in between primary memory to secondary memory
 viceversa.
 
    Ram
	harddisck/pendrive/flopydisck
	 
on top of files, we can perform two types of operations

  1.read operation
  2.write operation
  
  
already i have a file whcih contains some data
 
  -accessing the data. 
  -reading the data 
  
  -input stream 
  
   where file is available -> secondary memory device
   
    secondary memory to primary memory
	
  write opertion 
  
    -output stream 
	
    -storing the data 
	 
	 primary memory -> secondary memory
	 
	
data flow is happening in two forms

  1. byte stream -> byte by byte -> 8 bits at a time
  
  
  2. character stream -> character by character ->  2 bytes -> 16 bits
  
  

java.io package


character stream related classes:
`````````````````````````````````


  FileReader
  
  BufferReader
  
    -performing read/input stream  operations 
	

 	
 to perform the write operation or/ output strea operations
 
 
 
 
    -FileWriter
	-BufferedWriter
	-PrintWriter
	
	
	
how can we create the file in java:

  using File class 
  
   
example:
````````
package com.jse.ios;

import java.io.File;
import java.io.IOException;

public class Test1 {
	
	public static void main(String[] args) {
		
		//create the File class object
		
		File f = new File("abc.txt");
		try {
		f.createNewFile();
		
		System.out.println(f.exists());
		
		System.out.println("file created successfully");
		}
		catch(IOException ioe) {
			System.out.println(ioe);
		}
		
	}

}






FileWriter class:

Example:
````````

package com.jse.ios;

import java.io.FileWriter;
import java.io.IOException;

//writing this program to perform write operation
public class Test2 {
	
	public static void main(String[] args) {
		try {
		FileWriter fw = new FileWriter("abc.txt");
		
		fw.write("abc\n");
		fw.write(98+"\n");
		fw.write("freejavasessions\n");
		fw.write(100);
	
	
		
		fw.flush();
		
		System.out.println("write operation successfuly");
		
		
		
		
		
		
		
		}
		catch(IOException ioe)
		{
			System.out.println(ioe);
		}
		
	}

}


drawbacks of FileWriter:
`````````````````````````
1.adding \n for new line , it is not recommended because it may not work 
 in all operating systems sicne it got implemetned in c language.
 
2.we are not allowed to store specific type of data for example if we try to 
  store integer data it is getting automatically converted into unicode character which is not desired data.

  
BufferedWriter:
`````````````````

example:
`````````
package com.jse.ios;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

public class Test3 {
	public static void main(String[] args) {
		try {
		Writer obj  = new FileWriter("abc.txt");
		
		BufferedWriter bw = new BufferedWriter(obj);
		
		bw.write(100);
		bw.newLine();
		bw.write("abc");
		bw.newLine();
		bw.write("learnersstop");
		bw.newLine();
		bw.write("rk");
		bw.newLine();
		bw.write("vihasys");
		
		bw.flush();
		System.out.println("write operation has done");
		
		
		}
		catch(IOException io)
		{
			System.out.println(io);
		}
		
	}

}


drawbacks:
using BufferedWriter we are not allowed to store specific type of data 
for example if we pass integer data it is converted into unicode character and gets stored which is not desired value.

to avoid this drawback people will go for next level class


PrintWriter:
````````````
powerfull class
to perform write operations 

1.new line issue got resolved

2.any type of data we can store using PrintWriter class.



example:
```````````
package com.jse.ios;

import java.io.IOException;
import java.io.PrintWriter;

public class Test4 {
	
	public static void main(String[] args) {
		
		try {
		PrintWriter pw = new PrintWriter("abc.txt");
		
		//write the data
		
		pw.println(100);
		pw.println("abc");
		pw.println("rama");
		pw.println("learnersstop");
		
		pw.println(true);
		pw.println(23.45);
		
		pw.flush();
		
		System.out.println("write operation has done");
		
		
		
		
		
		}
		catch(IOException ioe)
		{
			System.out.println(ioe);
		}
		
	}

}
/*
output:
100
abc
rama
learnersstop
true
23.45

*/






read operation :
````````````````
FileReader
BufferedReader

FileReader
``````````
input stream 
secondary memory to primary memory 

read()-> used to read operation 
read() return type is integer
if we want to convert into character use type cast operator and then 
specify the desired data type.

example:
`````````
package com.jse.ios;

import java.io.FileReader;
import java.io.IOException;

public class Test5 {
	
	public static void main(String[] args) {
		try {
		FileReader fr = new FileReader("abc.txt");
		
		int x = fr.read();
		
		while(x!=-1) {
			System.out.print((char)x);
			x=fr.read();
		}
		
		//close the file
		fr.close();
	
		}
		catch(IOException ioe)
		{
			System.out.println(ioe);
		}
	}

}


drawback:
``````````
since it is a character stream related classes, character by character 
read operation is happening 
so that in between secondary memoryt to primary memory no.of to and fro 
calls gets increased /traffic gets increases because of this performance 
may be degraded.

that is why we will go for next level class i.e. BufferedReader.


BufferedReader:
```````````````

example:
`````````
package com.jse.ios;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;

//performing read operation using BufferedReader class
public class Test6 {
	
	
	public static void main(String[] args) {
		
		
		try {
		//create the Reader object
		
		Reader obj = new FileReader("abc.txt");
		//create the object of BufferedReader class
		
		BufferedReader br = new BufferedReader(obj);
		
		
		String result =br.readLine();
		
		while(result!=null)
		{
			System.out.println(result);
			result = br.readLine();
		}
		
		
		//close the files
		obj.close();
		br.close();
		
		
		}
		catch(IOException ioe)
		{
			System.out.println(ioe);
		}
		
		
		
		
	}

}


day-18:
```````
iostreams 

  read and write operations on top of files
  
  character stream related classes
   
     FileReader
	 BufferReader
	 FileWriter
	 BufferedWriter
	 PrintWriter
	 

  ->16bits at a time from pm to sm viceversa
  
  

java.io package


FileInputStream-reading purpose


FileOutputStream -writing purpose



  character strem -> text data
  
  bytestream related classes -> to read the raw data 
  
  image/audio/video
  
  
FileInputStream:
````````````````
A FileInputStream obtains input bytes from a file in a file system. What files are available depends on the host environment.


FileInputStream is meant for reading streams of raw bytes such as image data. 

For reading streams of characters, consider using FileReader.


example:
````````
package com.jse.ios;

import java.io.FileInputStream;
import java.io.IOException;

public class Test8 {
	
	public static void main(String[] args) {
		try {
		FileInputStream fis = new FileInputStream("abc.txt");
		
		int x = fis.read();
		
		while(x!=-1)
		{
			System.out.print((char)x);
			x=fis.read();
		}
		}
		catch(IOException ioe)
		{
			System.out.println(ioe);
		}
	}

}

FileOutputStream:
```````````````````
FileOutputStream is meant for writing streams of raw bytes such as image data. 

For writing streams of characters, consider using FileWriter.


example to read and write the image data using FileInputStream and FileOutputStream:


package com.jse.ios;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Test8 {
	
	public static void main(String[] args) {
		try {
		FileInputStream fis = new FileInputStream("stream-api.jpg");
		FileOutputStream fos = new FileOutputStream("benny.jpg");
		int x;
		while((x=fis.read())!=-1) {
			
			fos.write(x);
		}
		System.out.println("image created succesfully");
		}
		
		catch(IOException ioe)
		{
			System.out.println(ioe);
		}
	}

}


assignment:

do the same program using BufferedInputStream and BufferedOutputStream 


ByteArrayInputStream
ByteArrayOuputStream 


example:
`````````
package com.jse.ios;

import java.io.ByteArrayInputStream;
import java.io.IOException;

//the input stream is created using the array of bytes.
public class Test9 {

	public static void main(String[] args) {

		byte[] x = { 100, 97, 23 };

		ByteArrayInputStream ba = new ByteArrayInputStream(x);
		int ch = ba.read();

		while (ch != -1) {
			System.out.println(ch);
			ch = ba.read();
		}

	}

}

example:
````````
package com.jse.ios;

import java.io.ByteArrayInputStream;
import java.io.IOException;

//the input stream is created using the array of bytes.
public class Test9 {

	public static void main(String[] args) {

		String s = "welcome to freejavasessions";
		byte[] x = s.getBytes();

		ByteArrayInputStream ba = new ByteArrayInputStream(x);
		int ch = ba.read();

		while (ch != -1) {
			System.out.print((char)ch);
			ch = ba.read();
		}

	}

}


example:
````````
package com.jse.ios;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;

//the input stream is created using the array of bytes.
public class Test9 {

	public static void main(String[] args) {
		try {
			String data = "Hello free java sessions";
			ByteArrayOutputStream out = new ByteArrayOutputStream();

			byte[] array = data.getBytes();

			// writes data to the outputstream
			out.write(array);
			
			String streamData = out.toString();
			
			System.out.println(streamData);

		} catch (Exception e) {
			System.out.println(e);
		}

	}

}


assignment:
``````````
 DataInputStream 
 DataOutputStream
 
 
day-19:
````````

serialization and deserialization:

  serialization:
  ```````````````
  serialization is the process of writing the object data into 
  network supported format.
  
  our entire data -> object 
  it is not at all possible -network won't support this object format data.
  
  
  to achieve this serialization ,
  
  java.io 
   
  ObjectOutputStream 
  
    ->writeObject()
	

example:
`````````
Student.java:
`````````````
package com.jse.ios;

import java.io.Serializable;

public class Student implements Serializable{
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -6440716320753758977L;
	
	
	private int stid;
	private String stname;
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	public String toString()
	{
		return stid + " " + stname;
	}
	

}

Test10.java:
````````````
package com.jse.ios;

import java.io.FileOutputStream;
import java.io.ObjectOutputStream;

public class Test10 {
	
	public static void main(String[] args) {
		
		//create the object for ObjectOutputStream
		try {
		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("ram.ser"));
		
		Student stu = new Student();
		stu.setStid(100);
		stu.setStname("rama");
		
		oos.writeObject(stu);
		
		System.out.println("serialization process has done");
		
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
	}

}

Deserialization:
````````````````
it is the process of reading the object data from the network supported file.

 
  ->ObjectInputStream 
  
      ->readObject()
	  
	  

day-20:
```````
collection framework :
````````````````````

int x = 100;
int y = 200;
int z = 300;


 ->1000 values 
 1000 variables 
 
 to store 1000 values declaring 1000 varialbles, 
 is not a good programming practice.
 
 
Array:
  
   using arrays, we can store multiple values in a single variable.
   
   int x[]={100,200,300};
   
   
   int x[] =new Integer[5];
   
 -> the size is fixed in nature, you can't increase or decrease the memory 
    at runtime.
	
 -> using arrays, we can store only homogenious data, we can't store 
    heterogenous data.
	
 -> inside arrays, we don't have any ready made methods,to perform any 
    operation, we have to do manually.

 -> internally arrays are not following standard data structures.

 collection framework:
 ````````````````````
 it is the standardized mechanism of grouping similar type of data 
 and differnt type of data into a single entity. 
 
  ->java.util package
  
 

 
 few interfaces and few implementation clases

   1 Collection 
2.List
          3.Queue
                             4.Set
                             5.SortedSet


 

Collection:
`````````````

if we want to group similar objects and diffrent objects as a single entity 
then we should go for Collection .

note:
Collection is the root interface for all the remaining interface(s)
there is no direct implementation class for this Collection interface.


add()-to add an object

addAll(Collection)

remove()
removeAll()


List:
`````

  always working based on index
  
List is the predefined interface avaialble in java.util package

-> it allows both homogenious and heterogenous object(s)
-> insertion order is preserved
-> duplicates are allowed
-> null insertion is possible 

note:
 collection supports only object data.
 
 
 List l = new ArrayList();
 

example:
``````````
package com.jse.cfw;

import java.util.ArrayList;
import java.util.List;

public class Test1 {

	public static void main(String[] args) {
		
		//create the object for List
		
		List l = new ArrayList();
		
		//add the object
		l.add(Integer.valueOf(100));
		l.add(Integer.valueOf(200));
		l.add(new String("rama"));
		l.add(Boolean.valueOf(true));
		l.add(Integer.valueOf(100));
		l.add(null);
		
		System.out.println(l);//[100, 200, rama, true, 100, null]
		 		
		
		l.add(300);
		System.out.println(l);//[100, 200, rama, true, 100, null, 300]
		
		l.add(1, Integer.valueOf(300));
		
		System.out.println(l);//[100, 300, 200, rama, true, 100, null, 300]
	
		System.out.println(l.remove(1));
		
		System.out.println(l);//[100, 200, rama, true, 100, null, 300]
		
		l.remove(Integer.valueOf(100));
		
		System.out.println(l);//[200, rama, true, 100, null, 300]
		
		System.out.println("size of the collection : " + l.size());
		
		System.out.println(l.get(1));//rama
		
		System.out.println(l);//[200, rama, true, 100, null, 300]
		
		List l1 = new ArrayList();
		l1.add(500);
		l1.add(400);
		l1.add(600);
		
		l.addAll(l1);
		
		System.out.println(l);//[200, rama, true, 100, null, 300, 500, 400, 600]
		
		l.removeAll(l1);
		
		System.out.println(l);//[200, rama, true, 100, null, 300]
		
		
		System.out.println(l.contains(200));
		
		System.out.println(l.isEmpty());
		
		l.clear();
		System.out.println(l.isEmpty());
		
		System.out.println(l);//[]
		
		
	}
}


assignment:
do the same program w.r.to LinkedList


Collection 
List
   ArrayList
   LinkedList
   Stack
   Vector
   
   
  


  
day-21:
```````
eventhough we are passing primitive data internally it is getting converted
into object format.

autoboxing and autounboxing
`````````````````````````````

Autoboxing is the automatic conversion that the Java compiler makes between the primitive types and their corresponding object wrapper classes. 

For example, converting an int to an Integer, a double to a Double, and so on. If the conversion goes the other way, this is called unboxing.

java compiler:

autoboxing: primitive type to object type
autounboxing: object type to primitive type


difference between ArrayList and LinkedList:

ArrayList internally follows dynamic array algorithm to store the elements 
and if our frequent operation is accessing / retrieval then it is highly 
recommended to use this ArrayList.

   ArrayList implements RandomAccess
   {
   }


LinkedList internally follows doubly linkedlist algorithm where the data 
is getting stored based on the node wise. 
that's why if our frequent operation is insertion/deletion/updation we can 
go for LinkedList because no shift operations are happend like ArrayList.




Queue:
```````

Queue is also sub interface of Collection 

->if we want to represent a group of individual objects prior to processing
then we should go for Queue and Queue follow First In First Out algorithm



  Queue
  
   -ArrayDeque
   -LinkedList
   -PriorityQueue
   
   
boolean offer(Object obj)
Object poll()
Objet remove()
Object peek()-will give you head element->null
Object element()-will give you head element ->exception 

...

in case of ArrayDeque and LinkedList 

  -it allows both homogenious and heterogenous data
  -duplicates are allowed
  -insertion order is preserved
  -null insertion is possible only if implementation class is LinkedList
   in case of ArrayDeque it gives you NullPointerException

in case of PriorityQueue 

  -it allows only homogenious data
  -insertion order is not preserved
  -duplicates are allowed
  -null insertion is not possible if you try for that it gives you 
   NullPointerException 
   
   

example:
````````
package com.jse.cfw;

import java.util.ArrayDeque;
import java.util.LinkedList;
import java.util.Queue;

public class Test4 {
	
	public static void main(String[] args) {
		
		Queue obj = new LinkedList();
		
		obj.offer("rama");
		obj.offer("freejava");
		obj.offer("benny");
		obj.offer("shekhar");
		obj.offer("shekhar");
		obj.offer(null);
		
		
		
		
		
		
		System.out.println(obj);
		
		System.out.println(obj.poll());
		
		
		System.out.println("head: " +obj.element());
		
		System.out.println("head:" + obj.peek());
		
		obj.clear();
		
		//System.out.println(obj.element());//NoSuchElementException
		
	    System.out.println(obj.peek());
		
	}

}













  





  